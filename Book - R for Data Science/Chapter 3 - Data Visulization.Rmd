---
title: "Chapter 1 - Data Visualization"
output:
  html_document:
    df_print: paged
  html_notebook: default
  pdf_document: default
---
# Load packages
```{r}
install.packages("tidyverse")
library(tidyverse)
```


# 1 - Introduction
## 1.2 - Notes
Only talks about prerequisites

# 2 - First steps
## 2.1 - Notes
We are using the MPG data set. This comes with the tidyverse package.

A standard graphing template is as follows.

```{r}
ggplot(data = <DATA>) +
  <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))
```

## 2.2 - Exercises
**1 - Run plotting on mpg. What do you see?**

I run plotting on mpg:

```{r}
ggplot (data = mpg)
```

Doing this I see nothing. I need to define what I want to see

**2 - How many rows and columns are in mpg?**

I can find this using the str function, or alternatively glimpse. Or just writing the data in the console.

```{r}
str(mpg)
glimpse(mpg)
mpg
```


It is 234 rows and 11 columns.

**3 - what does the dr variable describe?**

I can find this by looking trough the documentation.
```{r}
?mpg
```

drv describes whether the car is f (front wheel drive), r (rear wheel drive), or 4 (4wd)

**4 - make a scatter-plot of hwy vs cyl**

I can do that using the following.
```{r}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = cyl, y = hwy))
```

**5 - What happens if you make a scatter-plot of class vs drv? Why is it not useful?**

This happens:
```{r}
ggplot(data = mpg) +
  geom_point(mapping = (aes(x = class, y = drv)))
```

This is not useful as the type of wheel setup (drv) is not dependent on type of car. One would expect.




# 3 - Aesthetic mappings
## 3.1 - Notes
Lets you highlight specific stuff. Aesthetics includes things like size, shape and color. One can use aesthetic mapping like this.
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = class))
```

Doing this will automatically assign a unique "level" of aesthetic (color) tp each unique value in the chosen variable (in this case: car class).

Here is the same example, using size instead.
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, size = class))
```
This gives us a different aesthetic, however, in this case it looks real messy. Other things we can map to is:
1. alpha = transparency
2. shape = shape
 
We can also set aesthetics manually like this.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")
```
Notice that the color is outside of the x and y parentheses, but still inside the aes.
 
You can look up information on the types of shapes that are available in R. There is a total of 25.
 
## 3.2 - Exercises
**1 - What's gone wrong with this code? Why are the points not blue?**
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = "blue"))
```
Answer: Because the deceleration for blue points are inside the x and Y parentheses, which creates a new variable in MPG called blue, which R attempts to color.

**2 - Which variables in mpg are categorical and continuous?**

We can figure this out by looking at the documentation.
```{r}
?mpg
```

It is somewhat difficult to look at the documentation. It is best to look at a printed data frame.
```{r}
mpg
```

Here we can see <chr> which stands for categorical and <dbl> or <int> which stand continuous. dbl is double precision vectors, or double - from C. I.E. a long float.

**3 - Map a continuous variable to color, size, and shape and look how they behave compared to categorical values**

I 
```{r}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = drv, y = hwy, color = year, size = cyl))
```
First it tells me that a continuous variable cant be mapped to shape. This makes sense.

As for color, it creates a gradient when used with continuous variables. Size also work with continuous variables, however, is not as good and rather scales the variables instead of having discrete sizes.


**4 - What happens if you map the same variable to multiple aesthetics?**

Lets try.

```{r}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = drv, y = hwy, color = trans, shape = trans))
```
Both things are mapped.

**5 - What does the stroke aesthetic do? What shapes does it work with?**

I can see this by looking at the documentation of geom_point.
```{r}
?geom_point
```


Stroke can modify the with of the border.
```{r}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = drv, y = hwy, color = year, size = cyl, stroke = cyl))
```
It can also do this:
```{r}
ggplot(mtcars, aes(wt, mpg)) +
  geom_point(shape = 21, colour = "black", fill = "white", size = 5, stroke = 5)
```


**6 - What happens if you map an aesthetic to something other than a variable name?**

Lets find out

```{r}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = drv, y = hwy, color = displ < 5))
```

You can get logical statements when doing this.

# 4 - Facets
## 4.1 - Notes
One additional way to show your data is to split your plot into subplots, also called facets. Facets can be created using the facet_wrap() function. There are several arguments you can supply to the facet function, including:
1. ~ = Formula (i.e. ~ class, nrow = 2)
2. grid = Two facets (i.e. drv ~ cyl)
3 . = neither rows nor columns (i.e. . ~ cyl)


## 4.1 - Exercises
**1 - What happens if you facet on a continious variable?**

Lets see.

```{r}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_wrap(~ cty, nrow = 2)
```

It looks messy!

**2 - What do the empty cells in a plot with facet_grid(drv ~ cyl) mean? How do they relate to this plot?**

```{r}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = drv, y = cyl))
```

Empty cells simply means that there are some drv and cyl combinations that have no values (hence empty). From the graph above I would guess that drv r with cyl 4 + 5 should be empty. Lets test that.

```{r}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = drv, y = cyl)) +
  facet_grid(drv ~ cyl)
```


This assumption seems to be correct.

**3 - What plots does the following code make? What does . do?**

First plot:
```{r}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(drv ~ .)
```

I would guess this would make a facet with one column and alot of rows.

Second plot:
```{r}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_wrap(. ~ drv)
```

I would guess this would make the opositte, a facet with one row and alot of columns. The . simply states that you dont want the facets in any dimensions. You can also use facet_wrap(~ drv, ncol=1).


**4 - Take this faceted plot. What are the advantages and disadvantages of using faceting instead of color aesthetic?**
```{r}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_wrap(~ class, nrow = 2)
  
```


Advantages
* You split up your view. Make it simpler if you have a larger dataset.
* If you have many variables to show, it can be difficult to see differences in shapes and colour.
* If the cases are somehow independent of each other.

Disadvantages
* If you just have a small dataset, it can seem empty.
* Difficult to compare direct values.

**5 - What does nrow and ncol do in  facets? And why does not facet_grid() have a nrow and ncol variable?**

I will need to look at the documentation of facets to figure this out.
```{r}
?facet_wrap
```

Ncol does: number of columns. nrow = number of rows. This is needed at facet wrap only facets on one variable.

These variables are not needed for facet_grid() as this function lays it out in rows and columns dependent on the data set.

**6 - When using facet_grid() you should usually put the variable with more unique levels in the columns, why?**

This is probably because it is easier to read if its longer in the column compared to rows.



# 4 - Geometric Objects
## 4.1 - Notes
You make different plots/graphs in R by using different geoms (geometric object). These can include:

* geom_point = scatter
```{r}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy))
```

* geom_smooth = line graph
```{r}
ggplot(data = mpg) +
  geom_smooth(mapping = aes(x = displ, y = hwy))
```


While all geoms takes mapping functions, they cant contain the same type of asthetics. For example a line graph is hard pressed to contain shapes, and different colours deppendent on the class. However, for smooth geoms you could for example set the line type like this:

```{r}
ggplot(data = mpg) +
  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv))
```

Here the function seperates the car dependent on the drivetrain type (drv). We can also do this, and add points to the graph to make it clearer, containing two geoms in the same graph, like this.
```{r}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy)) +
  geom_smooth(mapping = aes(x = displ, y = hwy))
```

The problem here is however that you esentially write the code two times. An alternative is to write code like this:
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y= hwy)) +
  geom_point(mapping = aes(color =class)) +
  geom_smooth()
```

Here you can also see that it is possible to place mapping functions inside only one geom and filter data, showing only some of it.

See the cheatsheet for an overview of all types of geoms.


## 4.1 - Exercises
**1 - What geom would you use to draw a line chart, boxplot, hisogram, or area chart?**

*To be honest, I dont know completly. Lets try it.

* Linechart = geom_smooth
* boxplot = geom_point
* histogram = geom_histogram
* area chart = geom_area

**2 - Run this code in your head. And predict outcome**

I predict that the below code with make a coloured line graph (based on drv) with points and without the standard error (SE = false).


```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) +
  geom_point() +
  geom_smooth(se = FALSE)
```
Correct!

**3 - What does show.legend = FALSE do? What happens if you remove it?**

It removes legends box. It still shows titles of rows and columns. 

**4 - What does the se arrgument in geom_smooth() do?**

It creates a standard error smoothing.

**5 - Will these two graphs look different? Why, why not?**

They will look the same. See below:

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point() +
  geom_smooth()
```

vs 
```{r}
ggplot() + 
  geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))
```

**6 - Recreate some R code that generates some plots I see in the book**

Plot 1
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point() + 
  geom_smooth(se = FALSE, color = "blue")
```


Plot 2:
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point() + 
  geom_smooth(se = FALSE, color = "blue", aes(group = drv), show.legend = FALSE)
```

Graph 3:
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) +
  geom_point() + 
  geom_smooth(aes(group = drv), se = FALSE)
```

Graph 4:


```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point(aes(color = drv)) + 
  geom_smooth(se = FALSE)
```

Graph 5: 
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point(aes(color = drv)) + 
  geom_smooth(se = FALSE, color = "blue", aes(linetype = drv))
```

Graph 6:
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point(aes(color = drv)) 
 
```

# 4 - Statistical Transformation
## 4.1 - Notes
Some plots automatically calculate new values for your plots. An example is the diaomonds data set where there is no count variable, however, this is calculated when using bar graphs. See this.
```{r}
ggplot(data = diamonds) +
  geom_bar(mapping = aes(x = cut))
```

When doing this, the plots bins the data, and counts the number/count that falls within each bin. This occurs for bar charts, histograms, and frequency polygons.

Other automatically calculated stuff can include smoothness model, and summary from boxplots.


The algorithms used for these transformations are called a stat (short for statistical transformation). 

You can see/view whch stat geoms uses by looking at the ? fuction.

```{r}
?geom_bar
```

Here it says ""geom_bar() uses stat_count() by default"".

You can actually use stats interchangibally. The previous graph can also be made like this.

```{r}
ggplot(data = diamonds) +
  stat_count(mapping = aes(x = cut))
```

There are three reasons you might choose to use stats over geoms.
1. Overide default stat (i.e. change from count to identity)
```{r}
demo <- tribble (
  ~a,       ~b,
  "bar_1",  20,
  "bar_2",  30,
  "bar_3",  40,
)

ggplot(data = demo) +
  geom_bar(mapping = aes(x = a, y = b), stat = "identity")
```

2. Overide defailt mapping. You might want to show something other than a normal Y column, for example proportion.
```{r}
ggplot(data = diamonds) +
  geom_bar(mapping = aes(x = cut, y = ..prop.., group = 1))
```

3. You can add more summary data to the plot.

```{r}
ggplot(data = diamonds) +
  stat_summary(mapping = aes(x = cut, y = depth), fun.ymin = min, fun.ymax = max, fun.y = median)
```




## 4.2 - Excersises
**1 - What is the default geom associated with stat_summary()? How could you rewrite the previous plat using geom instead of stat?**

I will first look at the documentation for stat_summary()

```{r}
?stat_summary
```

Here it says we can use geom_pointrange. Lets try that.

```{r}
ggplot(data = diamonds) +
  geom_pointrange(
    mapping = aes(x = cut, y = depth),
    stat = "summary",
    fun.ymin = min,
    fun.ymax = max,
    fun.y = median)

```

**2 - What does geom_col() do? How is it different to geom_bar()?**

Lets find out.
```{r}
?geom_col()
```

Geom_bar makes the height of the bar proportional to number of cases in each group. If you want them to be reperesent values in the acctual data, geom_col() does this. I.e. geom_bar() uses stat_count, while geom_col() uses stat_identity.


**3 - Most geoms and stats come in pairs that are almost always used in concert. What does these pairs have in common?**

We should read documentation.

```{r}
?stat_bin()
```

They often have similar names. They often do the same thing. Also, they use each other for the same thing. I.e. geom uses a stat, and a stat shows it using a geom. Dont really know why there are two types. Maybe to make it easier in edgecases.


**4 - What variables does stat_smooth() compute? What parameter controls its behavior?**

```{r}
?stat_smooth()
```

Stat smooth compute the SE using the predictdf function (usually). Also, y, ymin, and yma. The parameters that controls its behavior is method, formula, and na.rm.


**5 - What is the problems with these graphs?**

```{r}
ggplot(data = diamonds) +
  geom_bar(mapping = aes(x = cut, y = ..prop..))

ggplot(data = diamonds) +
  geom_bar(mapping = aes(x = cut, fill = color, y = ..prop.., group = 1))
```

The problem here is that they are all one. We need to set group to one. Prop is a groupwise proportion, and as such we need to have a group.
